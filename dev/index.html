<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ImageEdgeDetection.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ImageEdgeDetection.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Basic-usage"><span>Basic usage</span></a></li></ul></li><li><a class="tocitem" href="reference/">Function Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ImageEdgeDetection.jl-Documentation"><a class="docs-heading-anchor" href="#ImageEdgeDetection.jl-Documentation">ImageEdgeDetection.jl Documentation</a><a id="ImageEdgeDetection.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#ImageEdgeDetection.jl-Documentation" title="Permalink"></a></h1><p>A Julia package containing a number of algorithms for detecting edges in images.</p><ul><li><a href="#ImageEdgeDetection.jl-Documentation">ImageEdgeDetection.jl Documentation</a></li><ul><li><a href="#Getting-started">Getting started</a></li><li><a href="#Basic-usage">Basic usage</a></li></ul><li><a href="reference/#function_reference">Function References</a></li><ul><li><a href="reference/#General-function">General function</a></li><li><a href="reference/#Edge-Detection-Algorithms">Edge Detection Algorithms</a></li><ul><li><a href="reference/#Canny">Canny</a></li></ul><li><a href="reference/#Edge-Thinning-Algorithms">Edge Thinning Algorithms</a></li><ul><li><a href="reference/#Non-maxima-Suppression">Non-maxima Suppression</a></li><li><a href="reference/#Non-maxima-Suppression-(Subpixel)">Non-maxima Suppression (Subpixel)</a></li><li><a href="reference/#OrientationConvention">OrientationConvention</a></li></ul><li><a href="reference/#Supplementary-Types">Supplementary Types</a></li></ul></ul><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p>This package is part of a wider Julia-based image processing <a href="https://github.com/JuliaImages">ecosystem</a>. If you are starting out, then you may benefit from <a href="https://juliaimages.org/latest/quickstart/">reading</a> about some fundamental conventions that the ecosystem utilizes that are markedly different from how images are typically represented in OpenCV, MATLAB, ImageJ or Python.</p><p>The usage examples in the <code>ImageEdgeDetection.jl</code> package assume that you have already installed some key packages. Notably, the examples assume that you are able to load and display an image. Loading an image is facilitated through the <a href="https://github.com/JuliaIO/FileIO.jl">FileIO.jl</a> package, which uses <a href="https://github.com/JuliaIO/QuartzImageIO.jl">QuartzImageIO.jl</a> if you are on <code>MacOS</code>, and <a href="https://github.com/JuliaIO/ImageMagick.jl">ImageMagick.jl</a> otherwise. Depending on your particular system configuration, you might encounter problems installing the image loading packages, in which case you can refer to the <a href="https://juliaimages.org/latest/troubleshooting/#Installation-troubleshooting-1">troubleshooting guide</a>.</p><p>Image display is typically handled by the <a href="https://github.com/JuliaImages/ImageView.jl">ImageView.jl</a> package. Alternatives include the various plotting packages, including <a href="https://github.com/JuliaPlots/Makie.jl">Makie.jl</a>. There is also the <a href="https://github.com/JuliaImages/ImageShow.jl">ImageShow.jl</a> package which facilitates displaying images in <code>Jupyter</code> notebooks via <a href="https://github.com/JuliaLang/IJulia.jl">IJulia.jl</a>. Finally, one can also obtain a useful preview of an image in the REPL using the <a href="https://github.com/JuliaImages/ImageInTerminal.jl">ImageInTerminal.jl</a> package. However, this package assumes that the terminal uses a monospace font, and tends not to produce adequate results in a Windows environment.</p><p>Another package that is used to illustrate the functionality in <code>ImageEdgeDetection.jl</code> is the <a href="https://github.com/JuliaImages/TestImages.jl">TestImages.jl</a> which serves as a repository of many standard image processing test images.</p><h2 id="Basic-usage"><a class="docs-heading-anchor" href="#Basic-usage">Basic usage</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></h2><p>Each edge detection algorithm in <code>ImageEdgeDetection.jl</code> is an <a href="reference/#ImageEdgeDetection.EdgeDetectionAPI.AbstractEdgeDetectionAlgorithm"><code>AbstractEdgeDetectionAlgorithm</code></a>.</p><p>Suppose one wants to mark the edges in an image. This can be achieved by simply choosing an appropriate algorithm and calling <a href="reference/#ImageEdgeDetection.EdgeDetectionAPI.detect_edges"><code>detect_edges</code></a> or <a href="reference/#ImageEdgeDetection.EdgeDetectionAPI.detect_edges!"><code>detect_edges!</code></a> in the image.</p><p>Let&#39;s see a simple demo using the famous Canny edge detection algorithm:</p><pre><code class="language-julia">using TestImages, ImageEdgeDetection, MosaicViews
img =  testimage(&quot;mandril_gray&quot;)
# Detect edges at different scales by adjusting the `spatial_scale` parameter.
img_edges₁ = detect_edges(img, Canny(spatial_scale = 1.4))
img_edges₂ = detect_edges(img, Canny(spatial_scale = 2.8))
img_edges₃ = detect_edges(img, Canny(spatial_scale = 5.6))
demo₁ = mosaicview(img, img_edges₁, img_edges₂, img_edges₃; nrow = 2)</code></pre><pre class="documenter-example-output"> Downloading artifact: images</pre><img src="images/demo1.jpg" width="512px" alt="edge detection demo 1 image" />
<p><p>You can control the Canny hysteresis thresholds by setting appropriate keyword parameters.</p><pre><code class="language-julia"># Control the hysteresis thresholds by specifying the low and high threshold values.
img =  testimage(&quot;cameraman&quot;)
img_edges₄ = detect_edges(img, Canny(spatial_scale = 1.4, low = Percentile(5), high = Percentile(80)))
img_edges₅ = detect_edges(img, Canny(spatial_scale = 1.4, low = Percentile(60), high = Percentile(90)))
img_edges₆ = detect_edges(img, Canny(spatial_scale = 1.4, low = Percentile(70), high = Percentile(95)))
demo₂ = mosaicview(img, img_edges₄, img_edges₅, img_edges₆; nrow = 2)</code></pre><img src="images/demo2.jpg" width="512px" alt="edge detection demo 2 image" />
<p>
<p><p>Each edge thinning algorithm in <code>ImageEdgeDetection.jl</code> is an <a href="reference/#ImageEdgeDetection.EdgeDetectionAPI.AbstractEdgeThinningAlgorithm"><code>AbstractEdgeThinningAlgorithm</code></a>.</p><p>Suppose one wants to suppress the typical double edge response of an edge detection filter. This can be achieved by simply choosing an appropriate algorithm and calling <a href="reference/#ImageEdgeDetection.EdgeDetectionAPI.thin_edges"><code>thin_edges</code></a> or <a href="reference/#ImageEdgeDetection.EdgeDetectionAPI.thin_edges!"><code>thin_edges!</code></a> on the image gradients and gradient magnitudes.</p><p>For example, one can suppress undesirable multi-edge responses associated with the Sobel filter:</p><pre><code class="language-julia">using TestImages, ImageEdgeDetection, MosaicViews, ImageFiltering, ImageCore
img =  Gray.(testimage(&quot;lake_gray&quot;))
# Determine the image gradients
g₁, g₂ = imgradients(img, KernelFactors.sobel)
# Determine the gradient magnitude
mag = hypot.(g₁, g₂)
# Suppress the non-maximal gradient magnitudes
nms₁ = thin_edges(mag, g₁, g₂, NonmaximaSuppression())
nms₂ = thin_edges(mag, g₁, g₂, NonmaximaSuppression(threshold = Percentile(95)))
demo₃ = mosaicview(img, Gray.(nms₂), Gray.(mag), Gray.(nms₁); nrow = 2)</code></pre><img src="images/demo3.jpg" width="512px" alt="edge thinning demo image" />
<p><p>One can also determine the gradient orientation in an adjustable manner by defining an <a href="reference/#ImageEdgeDetection.OrientationConvention"><code>OrientationConvention</code></a>. An <code>OrientationConvention</code> allows you to specify the compass direction against  which you intend to measure the angle, and whether you are measuring in a clockwise or counter-clockwise manner.</p><p>In the example below, we map the angles <code>[0...360]</code> to the unit interval to visualise the orientation of the image gradient using different orientation conventions. Note that the angle <code>360</code> is used as a sentinel value to demarcate pixels for which the gradient orientation is undefined. The gradient orientation is undefined when the gradient magnitude is effectively zero. This corresponds to regions of constant intensity in the image. In the In the panel of images, the first image constitutes a black circle against a white background. The subsequent images depict the image gradient orientation, where the undefined gradient orientations are represent as pure white pixels.</p><pre><code class="language-julia">using ImageEdgeDetection, MosaicViews, ImageFiltering, ImageCore

# Create a test image (black circle against a white background).
a = 250
b = 250
r = 150
img = Gray.(ones(500, 500))
for i in CartesianIndices(img)
   y, x = i.I
   img[i] = (x-a)^2 + (y - b)^2 - r^2 &lt; 0 ? 0.0 : 1.0
end

# Determine the image gradients
g₁, g₂ = imgradients(img, KernelFactors.sobel)

orientation_convention₁ = OrientationConvention(in_radians = false, compass_direction = &#39;S&#39;)
orientation_convention₂ = OrientationConvention(in_radians = false, compass_direction = &#39;N&#39;)
orientation_convention₃ = OrientationConvention(in_radians = false, compass_direction = &#39;E&#39;, is_clockwise = true)

angles₁ = detect_gradient_orientation(g₁, g₂, orientation_convention₁) / 360
angles₂ = detect_gradient_orientation(g₁, g₂, orientation_convention₂) / 360
angles₃ = detect_gradient_orientation(g₁, g₂, orientation_convention₃) / 360

demo₄ = mosaicview(img, Gray.(angles₁), Gray.(angles₂), Gray.(angles₃); nrow = 2)</code></pre><img src="images/demo4.jpg" width="512px" alt="gradient orientation demo image" />
<p><p>For more advanced usage, please check <a href="reference/#function_reference">function reference</a> page.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="reference/">Function Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 2 August 2023 16:44">Wednesday 2 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
