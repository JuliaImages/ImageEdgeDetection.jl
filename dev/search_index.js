var documenterSearchIndex = {"docs":
[{"location":"#ImageEdgeDetection.jl-Documentation-1","page":"Home","title":"ImageEdgeDetection.jl Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A Julia package containing a number of algorithms for detecting edges in images.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Depth = 3","category":"page"},{"location":"#Getting-started-1","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package is part of a wider Julia-based image processing ecosystem. If you are starting out, then you may benefit from reading about some fundamental conventions that the ecosystem utilizes that are markedly different from how images are typically represented in OpenCV, MATLAB, ImageJ or Python.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The usage examples in the ImageEdgeDetection.jl package assume that you have already installed some key packages. Notably, the examples assume that you are able to load and display an image. Loading an image is facilitated through the FileIO.jl package, which uses QuartzImageIO.jl if you are on MacOS, and ImageMagick.jl otherwise. Depending on your particular system configuration, you might encounter problems installing the image loading packages, in which case you can refer to the troubleshooting guide.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Image display is typically handled by the ImageView.jl package. Alternatives include the various plotting packages, including Makie.jl. There is also the ImageShow.jl package which facilitates displaying images in Jupyter notebooks via IJulia.jl. Finally, one can also obtain a useful preview of an image in the REPL using the ImageInTerminal.jl package. However, this package assumes that the terminal uses a monospace font, and tends not to produce adequate results in a Windows environment.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Another package that is used to illustrate the functionality in ImageEdgeDetection.jl is the TestImages.jl which serves as a repository of many standard image processing test images.","category":"page"},{"location":"#Basic-usage-1","page":"Home","title":"Basic usage","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"TODO","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [ImageEdgeDetection]","category":"page"},{"location":"#ImageEdgeDetection.Canny","page":"Home","title":"ImageEdgeDetection.Canny","text":"    Canny <: AbstractEdgeDetectionAlgorithm\n    Canny(; spatial_scale = 1, high = Percentile(80), low = Percentile(20))\n\n    detect_edges([T,] img, f::Canny)\n    detect_edges!([out,] img, f::Canny)\n\nReturns a binary image depicting the edges of the input image.\n\nDetails\n\nTODO\n\nOptions\n\nVarious options for the parameters of the detect_edges function and Canny type are described in more detail below.\n\nChoices for img\n\nThe detect_edges function can handle a variety of input types. By default the type of the returned image is Gray{Bool}.\n\nFor colored images, the input is converted grayscale.\n\nChoices for spatial_scale in Canny.\n\nThe spatial_scale determines the radius (σ) of the Gaussian filter. It must be a positive real number.\n\nChoices for high and low in Canny.\n\nThe hysteresis thresholds high and low (high > low) can be specified as positive numbers, or as Percentiles. If left unspecified, a default value of high = Percentile(80) and low = Percentile(20) is assumed.\n\nExample\n\n\nusing TestImages, FileIO, ImageView\n\nimg =  testimage(\"mandril_gray\")\nimg_edges = detect_edges(img, Canny(spatial_scale = 1.4))\n\nimshow(img)\nimshow(img_edges)\n\nReferences\n\nJ. Canny, \"A Computational Approach to Edge Detection,\" in IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. PAMI-8, no. 6, pp. 679-698, Nov. 1986, doi: 10.1109/TPAMI.1986.4767851.\n\n\n\n\n\n","category":"type"},{"location":"#ImageEdgeDetection.NonmaximaSuppression","page":"Home","title":"ImageEdgeDetection.NonmaximaSuppression","text":"    NonmaximaSuppression <: AbstractEdgeThinningAlgorithm\n    NonmaximaSuppression(; threshold::Union{Number, Percentile} = Percentile(20))\n\n    f = NonmaximaSuppression()\n    f(out::AbstractArray, mag::AbstractArray, g₁::AbstractArray, g₂::AbstractArray, f::NonmaximaSuppression)\n\nIsolates local maxima of gradient magnitude mag along the local gradient direction and stores the result in out.  The arguments g₁ and g₂ represent the  gradient in the first spatial dimension (y), and the second spatial dimension (x), respectively.\n\nDetails\n\nTODO\n\nExample\n\n\nusing TestImages, FileIO, ImageView\n\nimg =  testimage(\"mandril_gray\")\n\n# Gradient in the first and second spatial dimension\ng₁, g₂ = imgradients(img, KernelFactors.scharr)\n\n# Gradient magnitude\nmag = hypot.(g₁, g₂)\n\nnms = zeros(eltype(mag), axes(mag))\n# Instantiate the NonmaximaSuppression functor.\nf = NonmaximaSuppression()\n\n# Suppress the non-maximal gradient magnitudes and store the result in `nms`.\nf(nms, mag, g₁, g₂)\n\nimshow(img)\nimshow(mag)\nimshow(nms)\n\nReferences\n\nJ. Canny, \"A Computational Approach to Edge Detection,\" in IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. PAMI-8, no. 6, pp. 679-698, Nov. 1986, doi: 10.1109/TPAMI.1986.4767851.\n\n\n\n\n\n","category":"type"},{"location":"#ImageEdgeDetection.Percentile","page":"Home","title":"ImageEdgeDetection.Percentile","text":"Percentile(x)\n\nIndicate that x should be interpreted as a percentile rather than an absolute value. For example,\n\ndetect_edges(img, Canny(high = 80, low = 20)) uses absolute thresholds on the edge magnitudes\ndetect_edges(img, Canny(high = Percentile(80), low = Percentile(20))) uses percentiles of the edge magnitude image as threshold\n\n\n\n\n\n","category":"type"},{"location":"#ImageEdgeDetection.suppress_non_maxima!-Tuple{AbstractArray,AbstractArray,AbstractArray,AbstractArray,Number}","page":"Home","title":"ImageEdgeDetection.suppress_non_maxima!","text":"    suppress_non_maxima!(out::AbstractArray, mag::AbstractArray, gx::AbstractArray, gy::AbstractArray, threshold::Number)\n\nIsolates local maxima of gradient magnitude by “non-maximum suppression” along the local gradient direction.\n\n\n\n\n\n","category":"method"},{"location":"#ImageEdgeDetection.trace_and_threshold!-Tuple{AbstractArray,AbstractArray,CartesianIndex,Number}","page":"Home","title":"ImageEdgeDetection.trace_and_threshold!","text":"    trace_and_threshold!(out::AbstractArray,  mag::AbstractArray, i₀::CartesianIndex, low::Number)\n\nMarks all pixels of an edge that are 8-connected to i₀ and exhibit a gradient magnitude above low.\n\n\n\n\n\n","category":"method"}]
}
