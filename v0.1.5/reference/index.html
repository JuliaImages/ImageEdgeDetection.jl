<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function Reference · ImageEdgeDetection.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ImageEdgeDetection.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Function Reference</a><ul class="internal"><li><a class="tocitem" href="#General-function"><span>General function</span></a></li><li><a class="tocitem" href="#Edge-Detection-Algorithms"><span>Edge Detection Algorithms</span></a></li><li><a class="tocitem" href="#Edge-Thinning-Algorithms"><span>Edge Thinning Algorithms</span></a></li><li><a class="tocitem" href="#Supplementary-Types"><span>Supplementary Types</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="function_reference"><a class="docs-heading-anchor" href="#function_reference">Function References</a><a id="function_reference-1"></a><a class="docs-heading-anchor-permalink" href="#function_reference" title="Permalink"></a></h1><ul><li><a href="#function_reference">Function References</a></li><ul><li><a href="#General-function">General function</a></li><li><a href="#Edge-Detection-Algorithms">Edge Detection Algorithms</a></li><ul><li><a href="#Canny">Canny</a></li></ul><li><a href="#Edge-Thinning-Algorithms">Edge Thinning Algorithms</a></li><ul><li><a href="#Non-maxima-Suppression">Non-maxima Suppression</a></li><li><a href="#Non-maxima-Suppression-(Subpixel)">Non-maxima Suppression (Subpixel)</a></li><li><a href="#OrientationConvention">OrientationConvention</a></li></ul><li><a href="#Supplementary-Types">Supplementary Types</a></li></ul></ul><h2 id="General-function"><a class="docs-heading-anchor" href="#General-function">General function</a><a id="General-function-1"></a><a class="docs-heading-anchor-permalink" href="#General-function" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ImageEdgeDetection.EdgeDetectionAPI.detect_edges" href="#ImageEdgeDetection.EdgeDetectionAPI.detect_edges"><code>ImageEdgeDetection.EdgeDetectionAPI.detect_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">out = detect_edges([T::Type,] img, f::AbstractEdgeDetectionAlgorithm, args...; kwargs...)</code></pre><p>Detect edges of <code>img</code> using algorithm <code>f</code>;  if left unspecified, <code>f</code> is assumed to be <a href="@ref ImageEdgeDetection.Canny"><code>Canny</code></a>.</p><p><strong>Output</strong></p><p>The return image <code>out</code> is an <code>Array{T}</code>. If <code>T</code> is not specified, then it&#39;s inferred.</p><p><strong>Examples</strong></p><p>Just simply pass the input image and algorithm to <code>detect_edges</code></p><pre><code class="language-julia">f = Canny(spatial_scale = 1.4)
img_edges = detect_edges(img, f)</code></pre><p>This reads as &quot;<code>detect_edges</code> of image <code>img</code> using algorithm <code>f</code>&quot;.</p><p>You can also explicitly specify the return type:</p><pre><code class="language-julia">f = Canny(spatial_scale = 1.4)
img_edges_float32 = detect_edges(Gray{Float32}, img, f)</code></pre><p>See also <a href="#ImageEdgeDetection.EdgeDetectionAPI.detect_edges!"><code>detect_edges!</code></a> for in-place edge detection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/76b273c361f56896474157647ac6fe0aa3afff0d/src/EdgeDetectionAPI/edge_detection.jl#L259-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageEdgeDetection.EdgeDetectionAPI.detect_edges!" href="#ImageEdgeDetection.EdgeDetectionAPI.detect_edges!"><code>ImageEdgeDetection.EdgeDetectionAPI.detect_edges!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">detect_edges!([out,] img, f::AbstractEdgeDetectionAlgorithm, args...; kwargs...)</code></pre><p>Detect edges of <code>img</code> using algorithm <code>f</code>;  if left unspecified, <code>f</code> is assumed to be <a href="@ref ImageEdgeDetection.Canny"><code>Canny</code></a>.</p><p><strong>Output</strong></p><p>If <code>out</code> is specified, it will be changed in place. Otherwise <code>img</code> will be changed in place.</p><p><strong>Examples</strong></p><p>Just simply pass an algorithm to <code>detect_edges!</code>:</p><pre><code class="language-julia">img_edges = similar(img)
detect_edges!(img_edges, img, f)</code></pre><p>For cases you just want to change <code>img</code> in place, you don&#39;t necessarily need to manually allocate <code>img_edges</code>; just use the convenient method:</p><pre><code class="language-julia">detect_edges!(img, f)</code></pre><p>See also: <a href="#ImageEdgeDetection.EdgeDetectionAPI.detect_edges"><code>detect_edges</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/76b273c361f56896474157647ac6fe0aa3afff0d/src/EdgeDetectionAPI/edge_detection.jl#L229-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageEdgeDetection.EdgeDetectionAPI.detect_subpixel_edges" href="#ImageEdgeDetection.EdgeDetectionAPI.detect_subpixel_edges"><code>ImageEdgeDetection.EdgeDetectionAPI.detect_subpixel_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">out₁, out₂ = detect_subpixel_edges([T₁::Type, T₂::Type], img, f::AbstractEdgeDetectionAlgorithm, args...; kwargs...)</code></pre><p>Detect edges of <code>img</code> to subpixel precision using algorithm <code>f</code>;  if left unspecified, <code>f</code> is assumed to be <a href="@ref ImageEdgeDetection.Canny"><code>Canny</code></a>.</p><p><strong>Output</strong></p><p>The integer components of an edge correspond to non-zero row and column entries in <code>out₁</code> which is an <code>Array{T₁}</code>. The accompanying subpixel offsets  are stored in a 2-D array <code>out₂</code> as length-2 vectors (<code>Array{SVector{2, T₂}}</code>). One can recover the  subpixel coordinates by adding the subpixel offsets to the integer components.</p><p><strong>Examples</strong></p><p>Just simply pass the input image and algorithm to <code>detect_subpixel_edges</code></p><pre><code class="language-julia">f = Canny(spatial_scale = 1.4, thinning_algorithm = SubpixelNonmaximaSuppression())
img_edges, offsets = detect_subpixel_edges(img, f)</code></pre><p>This reads as &quot;<code>detect_subpixel_edges</code> of image <code>img</code> using algorithm <code>f</code>&quot;.</p><p>You can also explicitly specify the return types:</p><pre><code class="language-julia">f = Canny(spatial_scale = 1.4, thinning_algorithm = SubpixelNonmaximaSuppression())
img_edges, offsets = detect_subpixel_edges(Gray{Float32}, Float32, img, f)</code></pre><p>See also <a href="#ImageEdgeDetection.EdgeDetectionAPI.detect_subpixel_edges!"><code>detect_subpixel_edges!</code></a> for in-place edge detection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/76b273c361f56896474157647ac6fe0aa3afff0d/src/EdgeDetectionAPI/edge_detection.jl#L321-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageEdgeDetection.EdgeDetectionAPI.detect_subpixel_edges!" href="#ImageEdgeDetection.EdgeDetectionAPI.detect_subpixel_edges!"><code>ImageEdgeDetection.EdgeDetectionAPI.detect_subpixel_edges!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">detect_subpixel_edges!(out₁, out₂, img, f::AbstractEdgeDetectionAlgorithm, args...; kwargs...)</code></pre><p>Detect edges of <code>img</code> to subpixel precision using algorithm <code>f</code>;  if left unspecified, <code>f</code> is assumed to be <a href="@ref ImageEdgeDetection.Canny"><code>Canny</code></a>.</p><p><strong>Output</strong></p><p>The integer components of an edge correspond to non-zero row and column entries in <code>out₁</code>. The accompanying subpixel offsets  are stored in a 2-D array <code>out₂</code> as length-2 vectors. One can recover the  subpixel coordinates by adding the subpixel offsets to the integer components.</p><p><strong>Examples</strong></p><p>Just simply pass an algorithm to <code>detect_subpixel_edges!</code>:</p><pre><code class="language-julia">f = Canny(spatial_scale = 1.4, thinning_algorithm = SubpixelNonmaximaSuppression())
img_edges = similar(img)
offsets = zeros(SVector{2,Float64}, axes(img))
detect_edges!(img_edges, offsets, img, f)</code></pre><p>See also: <a href="#ImageEdgeDetection.EdgeDetectionAPI.detect_subpixel_edges"><code>detect_subpixel_edges</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/76b273c361f56896474157647ac6fe0aa3afff0d/src/EdgeDetectionAPI/edge_detection.jl#L293-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageEdgeDetection.detect_gradient_orientation" href="#ImageEdgeDetection.detect_gradient_orientation"><code>ImageEdgeDetection.detect_gradient_orientation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">detect_gradient_orientation(g₁::AbstractArray, g₂::AbstractArray, orientation_convention::OrientationConvention, args...; kwargs...)</code></pre><p>Given the gradient in the first (<code>g₁</code>) and second (<code>g₂</code>) spatial dimensions, returns the gradient orientation, where the orientation is interpreted according to a supplied <a href="#ImageEdgeDetection.OrientationConvention"><code>OrientationConvention</code></a>.</p><p><strong>Details</strong></p><p>You can specify how you want the gradient orientation to be reported by supplying an <a href="#ImageEdgeDetection.OrientationConvention"><code>OrientationConvention</code></a>. If left unspecified the orientation is measured counter-clockwise from the south direction. This is because in a Raster coordinate system, the first spatial dimension increases as one goes down the image (i.e. it points south), and the second spatial dimension increases as one moves to the right of the image (i.e. it points east).</p><p>If you wish to interpret the orientation in a canonical Cartesian coordinate convention you would specify east as the reference compass direction (<code>compass_direction = &#39;E&#39;</code>) and a counter-clockwise direction (<code>clockwise = false</code>).</p><p><strong>Output</strong></p><p>Returns a two-dimensional array of angles. If <code>in_radians = true</code> the valid angles are reported in the range of <code>[0...2π)</code>, otherwise they are reported in the range <code>[0...360)</code>. The values <code>2π</code> and <code>360</code> are used as sentinels to designate undefined angles (because the gradient magnitude was too close to zero). By default, an angle is undefined if <code>(abs(g₁) &lt; tol &amp;&amp; abs(g₂) &lt; tol)</code> where <code>g₁</code> and <code>g₂</code> denote the gradient in the first and second spatial dimensions, and <code>tol = sqrt(eps(Float64))</code> (as defined in <a href="#ImageEdgeDetection.OrientationConvention"><code>OrientationConvention</code></a>).</p><p>See also: <a href="#ImageEdgeDetection.detect_gradient_orientation!"><code>detect_gradient_orientation!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/76b273c361f56896474157647ac6fe0aa3afff0d/src/algorithms/gradient_orientation.jl#L59-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageEdgeDetection.detect_gradient_orientation!" href="#ImageEdgeDetection.detect_gradient_orientation!"><code>ImageEdgeDetection.detect_gradient_orientation!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">detect_gradient_orientation(out::AbstractArray, g₁::AbstractArray, g₂::AbstractArray, orientation_convention::OrientationConvention, args...; kwargs...)</code></pre><p>Given the gradient in the first (<code>g₁</code>) and second (<code>g₂</code>) spatial dimensions, returns the gradient orientation in <code>out</code>, where the orientation is interpreted according to a supplied <a href="#ImageEdgeDetection.OrientationConvention"><code>OrientationConvention</code></a>.</p><p><strong>Details</strong></p><p>You can specify how you want the gradient orientation to be reported by supplying an <a href="#ImageEdgeDetection.OrientationConvention"><code>OrientationConvention</code></a>. If left unspecified the orientation is measured counter-clockwise in radians from the south direction. This is because in a Raster coordinate system, the first spatial dimension increases as one goes down the image (i.e. it points south), and the second spatial dimension increases as one moves to the right of the image (i.e. it points east).</p><p>If you wish to interpret the orientation in a canonical Cartesian coordinate convention you would specify east as the reference compass direction (<code>compass_direction = &#39;E&#39;</code>) and a counter-clockwise direction (<code>clockwise = false</code>).</p><p><strong>Output</strong></p><p>Returns a two-dimensional array of angles. If <code>in_radians = true</code> genuine angles are reported in the range of <code>[0...2π)</code>, otherwise they are reported in the range <code>[0...360)</code>. The values <code>2π</code> and <code>360</code> are used as sentinels to designate undefined angles (because the gradient magnitude was too close to zero). By default, an angle is undefined if <code>(abs(g₁) &lt; tol &amp;&amp; abs(g₂) &lt; tol)</code> where <code>g₁</code> and <code>g₂</code> denote the gradient in the first and second spatial dimensions, and <code>tol = sqrt(eps(eltype(out)))</code> (as defined in <a href="#ImageEdgeDetection.OrientationConvention"><code>OrientationConvention</code></a>).</p><p>See also: <a href="#ImageEdgeDetection.detect_gradient_orientation"><code>detect_gradient_orientation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/76b273c361f56896474157647ac6fe0aa3afff0d/src/algorithms/gradient_orientation.jl#L108-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageEdgeDetection.EdgeDetectionAPI.thin_edges" href="#ImageEdgeDetection.EdgeDetectionAPI.thin_edges"><code>ImageEdgeDetection.EdgeDetectionAPI.thin_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">thin_edges([T::Type,] mag, g₁, g₂, f::AbstractEdgeThinningAlgorithm, args...; kwargs...)</code></pre><p>Using algorithm <code>f</code>, thin the edge-response based on the edge magnitude <code>mag</code>, the  gradient in the first spatial dimension <code>g₁</code>, and the gradient in the second spatial dimension <code>g₂</code>.</p><p><strong>Output</strong></p><p>Returns an <code>Array{T}</code> representing the thinned edge response.</p><p>If <code>T</code> is not specified, then it&#39;s inferred. Note that <code>T</code> must represent or wrap a floating point number.</p><p><strong>Examples</strong></p><p>Just simply pass the input image and algorithm to <code>thin_edges</code></p><pre><code class="language-julia">using TestImages, ImageFiltering
img =  Gray.(testimage(&quot;mandril&quot;))

# Gradient in the first and second spatial dimension
g₁, g₂ = imgradients(img, KernelFactors.scharr)

# Gradient magnitude
mag = hypot.(g₁, g₂)

f = NonmaximaSuppression(threshold = Percentile(10))

thinned_edges = thin_edges(mag, g₁, g₂, f)</code></pre><p>This reads as &quot;<code>thin_edges</code> based on the edge response magnitude, and spatial gradients, using algorithm <code>f</code>&quot;.</p><p>You can also explicitly specify the return type:</p><pre><code class="language-julia">thinned_edges_float32 = thin_edges(Gray{Float32}, mag, g₁, g₂, f)</code></pre><p>See also <a href="#ImageEdgeDetection.EdgeDetectionAPI.thin_edges!"><code>thin_edges!</code></a> for in-place edge thinning.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/76b273c361f56896474157647ac6fe0aa3afff0d/src/EdgeDetectionAPI/edge_thinning.jl#L143-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageEdgeDetection.EdgeDetectionAPI.thin_edges!" href="#ImageEdgeDetection.EdgeDetectionAPI.thin_edges!"><code>ImageEdgeDetection.EdgeDetectionAPI.thin_edges!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">thin_edges!([out,] mag, g₁, g₂, f::AbstractEdgeThinningAlgorithm, args...; kwargs...)</code></pre><p>Isolate local maxima of gradient magnitude <code>mag</code> along the local gradient direction. The arguments <code>g₁</code> and <code>g₂</code> represent the  gradient in the first spatial dimension (y), and the second spatial dimension (x), respectively.</p><p><strong>Output</strong></p><p>If <code>out</code> is specified, it will be changed in place. Otherwise <code>mag</code> will be changed in place.</p><p><strong>Examples</strong></p><p>Just simply pass an algorithm to <code>thin_edges!</code>:</p><pre><code class="language-julia">using TestImages, ImageFiltering
img =  Gray.(testimage(&quot;mandril&quot;))

# Gradient in the first and second spatial dimension
g₁, g₂ = imgradients(img, KernelFactors.scharr)

# Gradient magnitude
mag = hypot.(g₁, g₂)

f = SubpixelNonmaximaSuppression(threshold = Percentile(10))

thinned_edges = zeros(eltype(mag), axes(mag))
thin_edges!(thinned_edges, mag, g₁, g₂, f)</code></pre><p>For cases you just want to change <code>mag</code> in place, you don&#39;t necessarily need to manually allocate <code>thinned_edges</code>; just use the convenient method:</p><pre><code class="language-julia">thin_edges!(mag, g₁, g₂, f)</code></pre><p>See also: <a href="#ImageEdgeDetection.EdgeDetectionAPI.thin_edges"><code>thin_edges</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/76b273c361f56896474157647ac6fe0aa3afff0d/src/EdgeDetectionAPI/edge_thinning.jl#L101-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageEdgeDetection.EdgeDetectionAPI.thin_subpixel_edges" href="#ImageEdgeDetection.EdgeDetectionAPI.thin_subpixel_edges"><code>ImageEdgeDetection.EdgeDetectionAPI.thin_subpixel_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">out₁, out₂ = thin_subpixel_edges(mag, g₁, g₂, f::AbstractEdgeThinningAlgorithm, args...; kwargs...)</code></pre><p>Isolate local maxima of gradient magnitude <code>mag</code> along the local gradient direction. The arguments <code>g₁</code> and <code>g₂</code> represent the  gradient in the first spatial dimension (y), and the second spatial dimension (x), respectively.</p><p><strong>Output</strong></p><p>The integer components of the local maxima correspond to non-zero row and column entries in <code>out₁</code>. The accompanying subpixel offsets  are stored in a 2-D array <code>out₂</code> as length-2 vectors. One can recover the  subpixel coordinates by adding the subpixel offsets to the integer components.</p><p><strong>Examples</strong></p><p>Just simply pass an algorithm to <code>thin_subpixel_edges</code>:</p><pre><code class="language-julia">using TestImages, ImageFiltering
img =  Gray.(testimage(&quot;mandril&quot;))

# Gradient in the first and second spatial dimension
g₁, g₂ = imgradients(img, KernelFactors.scharr)

# Gradient magnitude
mag = hypot.(g₁, g₂)

f = SubpixelNonmaximaSuppression(threshold = Percentile(10))

thinned_edges, offsets = thin_subpixel_edges(mag, g₁, g₂, f)</code></pre><p>See also: <a href="#ImageEdgeDetection.EdgeDetectionAPI.thin_subpixel_edges!"><code>thin_subpixel_edges!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/76b273c361f56896474157647ac6fe0aa3afff0d/src/EdgeDetectionAPI/edge_thinning.jl#L188-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageEdgeDetection.EdgeDetectionAPI.thin_subpixel_edges!" href="#ImageEdgeDetection.EdgeDetectionAPI.thin_subpixel_edges!"><code>ImageEdgeDetection.EdgeDetectionAPI.thin_subpixel_edges!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">thin_subpixel_edges!(out₁, out₂, mag, g₁, g₂, f::AbstractEdgeThinningAlgorithm, args...; kwargs...)</code></pre><p>Isolate local maxima of gradient magnitude <code>mag</code> along the local gradient direction. The arguments <code>g₁</code> and <code>g₂</code> represent the  gradient in the first spatial dimension (y), and the second spatial dimension (x), respectively.</p><p><strong>Output</strong></p><p>The integer components of the local maxima correspond to non-zero row and column entries in <code>out₁</code>. The accompanying subpixel offsets  are stored in a 2-D array <code>out₂</code> as length-2 vectors. One can recover the  subpixel coordinates by adding the subpixel offsets to the integer components.</p><p><strong>Examples</strong></p><p>Just simply pass an algorithm to <code>thin_subpixel_edges!</code>:</p><pre><code class="language-julia">using TestImages, ImageFiltering
img =  Gray.(testimage(&quot;mandril&quot;))

# Gradient in the first and second spatial dimension
g₁, g₂ = imgradients(img, KernelFactors.scharr)

# Gradient magnitude
mag = hypot.(g₁, g₂)

f = SubpixelNonmaximaSuppression(threshold = Percentile(10))

thinned_edges = zeros(eltype(mag), axes(mag))
offsets = zeros(SVector{2,Float64}, axes(mag))
thin_subpixel_edges!(thinned_edges, offsets, mag, g₁, g₂, f)</code></pre><p>See also: <a href="#ImageEdgeDetection.EdgeDetectionAPI.thin_subpixel_edges"><code>thin_subpixel_edges</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/76b273c361f56896474157647ac6fe0aa3afff0d/src/EdgeDetectionAPI/edge_thinning.jl#L227-L264">source</a></section></article><h2 id="Edge-Detection-Algorithms"><a class="docs-heading-anchor" href="#Edge-Detection-Algorithms">Edge Detection Algorithms</a><a id="Edge-Detection-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Edge-Detection-Algorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ImageEdgeDetection.EdgeDetectionAPI.AbstractEdgeDetectionAlgorithm" href="#ImageEdgeDetection.EdgeDetectionAPI.AbstractEdgeDetectionAlgorithm"><code>ImageEdgeDetection.EdgeDetectionAPI.AbstractEdgeDetectionAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractEdgeDetectionAlgorithm &lt;: AbstractImageFilter</code></pre><p>The root type for <code>ImageEdgeDetection</code> package.</p><p>Any concrete edge detection algorithm shall subtype it to support <a href="#ImageEdgeDetection.EdgeDetectionAPI.detect_edges"><code>detect_edges</code></a>, <a href="#ImageEdgeDetection.EdgeDetectionAPI.detect_edges!"><code>detect_edges!</code></a>, <a href="#ImageEdgeDetection.EdgeDetectionAPI.detect_subpixel_edges"><code>detect_subpixel_edges</code></a> and <a href="#ImageEdgeDetection.EdgeDetectionAPI.detect_subpixel_edges!"><code>detect_subpixel_edges!</code></a> APIs.</p><p><strong>Examples</strong></p><p>All edge detection algorithms in ImageEdgeDetection are called in the following pattern:</p><pre><code class="language-julia"># first generate an algorithm instance
f = Canny()

# then pass the algorithm to `detect_edges`
img_edges = detect_edges(img, f)

# or use in-place version `detect_edges!`
img_edges = similar(img)
detect_edges!(img_edges, img, f)</code></pre><p>For more examples, please check <a href="#ImageEdgeDetection.EdgeDetectionAPI.detect_edges"><code>detect_edges</code></a>, <a href="#ImageEdgeDetection.EdgeDetectionAPI.detect_edges!"><code>detect_edges!</code></a> and concrete algorithms.</p><p>One can also detect edges to subpixel accuracy by specifying <code>SubpixelNonmaximaSuppression</code> as the edge thinning algorithm and using <a href="#ImageEdgeDetection.EdgeDetectionAPI.detect_subpixel_edges"><code>detect_subpixel_edges</code></a> or <a href="#ImageEdgeDetection.EdgeDetectionAPI.detect_subpixel_edges!"><code>detect_subpixel_edges!</code></a>. The function returns an edge image as well as a accompanying matrix of length-2 vectors which, when added to the edge image coordinates, specify the location of an edge to subpixel precision.</p><pre><code class="language-julia"># first generate an algorithm instance
f = Canny(thinning_algorithm = SubpixelNonmaximaSuppression())

# then pass the algorithm to `detect_subpixel_edges`
img_edges, subpixel_offsets = detect_subpixel_edges(img, f)

# or use in-place version `detect_edges!`
img_edges = similar(img)
subpixel_offsets = zeros(SVector{2,Float64}, axes(img))
detect_edges!(img_edges, subpixel_offsets, img, f)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/76b273c361f56896474157647ac6fe0aa3afff0d/src/EdgeDetectionAPI/edge_detection.jl#L7-L57">source</a></section></article><h3 id="Canny"><a class="docs-heading-anchor" href="#Canny">Canny</a><a id="Canny-1"></a><a class="docs-heading-anchor-permalink" href="#Canny" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ImageEdgeDetection.Canny" href="#ImageEdgeDetection.Canny"><code>ImageEdgeDetection.Canny</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">    Canny &lt;: AbstractEdgeDetectionAlgorithm
    Canny(; spatial_scale = 1, high = Percentile(80), low = Percentile(20), thinning_algorithm = NonmaximaSuppression(threshold = low))

    detect_edges([T,] img, f::Canny)
    detect_edges!([out,] img, f::Canny)
    detect_subpixel_edges([T₁, T₂] img, f::Canny)
    detect_subpixel_edges!(out₁, out₂, img, f::Canny)</code></pre><p>Returns a binary image depicting the edges of the input image.</p><p><strong>Details</strong></p><p>TODO</p><p><strong>Options</strong></p><p>Various options for the parameters of the <code>detect_edges</code> function and <code>Canny</code> type are described in more detail below.</p><p><strong>Choices for img</strong></p><p>The <code>detect_edges</code> function can handle a variety of input types. By default the type of the returned image matches the type of the input image.</p><p>For colored images, the input is converted to grayscale.</p><p><strong>Choices for <code>spatial_scale</code> in <code>Canny</code>.</strong></p><p>The <code>spatial_scale</code> determines the radius (σ) of the Gaussian filter. It must be a positive real number.</p><p><strong>Choices for <code>high</code> and <code>low</code> in <code>Canny</code>.</strong></p><p>The hysteresis thresholds <code>high</code> and <code>low</code> (<code>high</code> &gt; <code>low</code>) can be specified as positive numbers, or as <code>Percentiles</code>. If left unspecified, a default value of <code>high = Percentile(80)</code> and <code>low = Percentile(20)</code> is assumed.</p><p><strong>Choices for <code>thinning_algorithm</code> in <code>Canny</code>.</strong></p><p>You can specify an <a href="#ImageEdgeDetection.EdgeDetectionAPI.AbstractEdgeThinningAlgorithm"><code>AbstractEdgeThinningAlgorithm</code></a>. By default, the <a href="#ImageEdgeDetection.NonmaximaSuppression"><code>NonmaximaSuppression</code></a> algorithm is used which suppresses non-maxima up to pixel-level accuracy. For subpixel precision specify the <a href="#ImageEdgeDetection.SubpixelNonmaximaSuppression"><code>SubpixelNonmaximaSuppression</code></a> algorithm.</p><p><strong>Example</strong></p><pre><code class="language-julia">
using TestImages, FileIO, ImageView

img =  testimage(&quot;mandril_gray&quot;)
img_edges = detect_edges(img, Canny(spatial_scale = 1.4))

imshow(img)
imshow(img_edges)</code></pre><p><strong>References</strong></p><p>J. Canny, &quot;A Computational Approach to Edge Detection,&quot; in IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. PAMI-8, no. 6, pp. 679-698, Nov. 1986, doi: 10.1109/TPAMI.1986.4767851.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/76b273c361f56896474157647ac6fe0aa3afff0d/src/algorithms/canny.jl#L1-L63">source</a></section></article><h2 id="Edge-Thinning-Algorithms"><a class="docs-heading-anchor" href="#Edge-Thinning-Algorithms">Edge Thinning Algorithms</a><a id="Edge-Thinning-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Edge-Thinning-Algorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ImageEdgeDetection.EdgeDetectionAPI.AbstractEdgeThinningAlgorithm" href="#ImageEdgeDetection.EdgeDetectionAPI.AbstractEdgeThinningAlgorithm"><code>ImageEdgeDetection.EdgeDetectionAPI.AbstractEdgeThinningAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractEdgeThinningAlgorithm &lt;: AbstractImageFilter</code></pre><p>A root type for <code>ImageEdgeDetection</code> package.</p><p>Any concrete edge thinning algorithm shall subtype it to support <a href="#ImageEdgeDetection.EdgeDetectionAPI.thin_edges"><code>thin_edges</code></a>, <a href="#ImageEdgeDetection.EdgeDetectionAPI.thin_edges!"><code>thin_edges!</code></a>, <a href="#ImageEdgeDetection.EdgeDetectionAPI.thin_subpixel_edges"><code>thin_subpixel_edges</code></a> and <a href="#ImageEdgeDetection.EdgeDetectionAPI.thin_subpixel_edges!"><code>thin_subpixel_edges!</code></a>  APIs.</p><p><strong>Examples</strong></p><p>All edge thinning algorithms in ImageEdgeDetection are called in the following pattern:</p><pre><code class="language-julia"># first generate an algorithm instance
f = NonmaximaSuppression()

# determine the image gradients
g₁, g₂ = imgradients(img, KernelFactors.scharr)

# determine the gradient magnitude
mag = hypot.(g₁, g₂)

# then pass the algorithm to `thin_edges`
thinned_edges = thin_edges(mag, g₁, g₂, f)

# or use in-place version `thin_edges!`
thinned_edges = zeros(eltype(mag), axes(mag))
thin_edges!(thinned_edges, mag, g₁, g₂, f)</code></pre><p>For more examples, please check <a href="#ImageEdgeDetection.EdgeDetectionAPI.thin_edges"><code>thin_edges</code></a>, <a href="#ImageEdgeDetection.EdgeDetectionAPI.thin_edges!"><code>thin_edges!</code></a> and concrete algorithms.</p><p>One can also perform non-maxima suppression to subpixel precision using <a href="#ImageEdgeDetection.EdgeDetectionAPI.thin_subpixel_edges"><code>thin_subpixel_edges</code></a> and <a href="#ImageEdgeDetection.EdgeDetectionAPI.thin_subpixel_edges!"><code>thin_subpixel_edges!</code></a>. The function returns an edge image as well as a accompanying matrix of length-2 vectors which, when added to the edge image coordinates, specify the location of an edge to subpixel precision.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/76b273c361f56896474157647ac6fe0aa3afff0d/src/EdgeDetectionAPI/edge_thinning.jl#L7-L48">source</a></section></article><h3 id="Non-maxima-Suppression"><a class="docs-heading-anchor" href="#Non-maxima-Suppression">Non-maxima Suppression</a><a id="Non-maxima-Suppression-1"></a><a class="docs-heading-anchor-permalink" href="#Non-maxima-Suppression" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ImageEdgeDetection.NonmaximaSuppression" href="#ImageEdgeDetection.NonmaximaSuppression"><code>ImageEdgeDetection.NonmaximaSuppression</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">    NonmaximaSuppression &lt;: AbstractEdgeThinningAlgorithm
    NonmaximaSuppression(; threshold::Union{Number, Percentile} = Percentile(20))

    f = NonmaximaSuppression()
    f(out::AbstractArray, mag::AbstractArray, g₁::AbstractArray, g₂::AbstractArray, f::NonmaximaSuppression)</code></pre><p>Isolates local maxima of gradient magnitude <code>mag</code> along the local gradient direction and stores the result in <code>out</code>.  The arguments <code>g₁</code> and <code>g₂</code> represent the  gradient in the first spatial dimension (y), and the second spatial dimension (x), respectively.</p><p><strong>Details</strong></p><p>TODO</p><p><strong>Example</strong></p><pre><code class="language-julia">
using TestImages, FileIO, ImageView, ImageEdgeDetection, ImageFiltering

img =  testimage(&quot;mandril_gray&quot;)

# Gradient in the first and second spatial dimension
g₁, g₂ = imgradients(img, KernelFactors.scharr)

# Gradient magnitude
mag = hypot.(g₁, g₂)

nms = zeros(eltype(mag), axes(mag))
# Instantiate the NonmaximaSuppression functor.
f = NonmaximaSuppression()

# Suppress the non-maximal gradient magnitudes and store the result in `nms`.
f(nms, mag, g₁, g₂)

imshow(img)
imshow(mag)
imshow(nms)</code></pre><p><strong>References</strong></p><p>J. Canny, &quot;A Computational Approach to Edge Detection,&quot; in IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. PAMI-8, no. 6, pp. 679-698, Nov. 1986, doi: 10.1109/TPAMI.1986.4767851.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/76b273c361f56896474157647ac6fe0aa3afff0d/src/algorithms/nonmaxima_suppression.jl#L1-L47">source</a></section></article><h3 id="Non-maxima-Suppression-(Subpixel)"><a class="docs-heading-anchor" href="#Non-maxima-Suppression-(Subpixel)">Non-maxima Suppression (Subpixel)</a><a id="Non-maxima-Suppression-(Subpixel)-1"></a><a class="docs-heading-anchor-permalink" href="#Non-maxima-Suppression-(Subpixel)" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ImageEdgeDetection.SubpixelNonmaximaSuppression" href="#ImageEdgeDetection.SubpixelNonmaximaSuppression"><code>ImageEdgeDetection.SubpixelNonmaximaSuppression</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">    SubpixelNonmaximaSuppression &lt;: AbstractEdgeThinningAlgorithm
    SubpixelNonmaximaSuppression(; threshold::Union{Number, Percentile} = Percentile(20))

    f = SubpixelNonmaximaSuppression()
    f(out₁::AbstractArray, out₂::Matrix{&lt;:AbstractArray}, mag::AbstractArray, g₁::AbstractArray, g₂::AbstractArray, f::SubpixelNonmaximaSuppression)</code></pre><p>Isolates local maxima of gradient magnitude <code>mag</code> along the local gradient direction to subpixel precision.  The arguments <code>g₁</code> and <code>g₂</code> represent the gradient in the first spatial dimension (y), and the second spatial dimension (x), respectively.</p><p>The integer components of the local maxima correspond to non-zero row and column entries <code>out₁</code>. The accompanying subpixel offsets  are stored in a 2-D array <code>out₂</code> as length-2 vectors. One can recover the  subpixel coordinates by adding the subpixel offsets to the integer components.</p><p><strong>Details</strong></p><p>TODO</p><p><strong>Example</strong></p><pre><code class="language-julia">
using TestImages, FileIO, ImageView, ImageEdgeDetection, ImageFiltering

img =  testimage(&quot;mandril_gray&quot;)

# Gradient in the first and second spatial dimension
g₁, g₂ = imgradients(img, KernelFactors.scharr)

# Gradient magnitude
mag = hypot.(g₁, g₂)

nms = zeros(eltype(mag), axes(mag))
subpixel_offsets = zeros(SVector{2,Float64}, axes(mag))

# Instantiate the NonmaximaSuppression functor.
f = SubpixelNonmaximaSuppression()

# Suppress the non-maximal gradient magnitudes and store the result in `nms`.
f(nms, subpixel_offsets, mag, g₁, g₂)

imshow(img)
imshow(mag)
imshow(nms)</code></pre><p><strong>References</strong></p><ol><li>J. Canny, &quot;A Computational Approach to Edge Detection,&quot; in IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. PAMI-8, no. 6, pp. 679-698, Nov. 1986, doi: 10.1109/TPAMI.1986.4767851.</li><li>F. Devernay, &quot;A non-maxima suppression method for edge detection with sub-pixel accuracy&quot;, Tech. Report RR-2724, INRIA, 1995.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/76b273c361f56896474157647ac6fe0aa3afff0d/src/algorithms/subpixel_nonmaxima_suppression.jl#L1-L56">source</a></section></article><h3 id="OrientationConvention"><a class="docs-heading-anchor" href="#OrientationConvention">OrientationConvention</a><a id="OrientationConvention-1"></a><a class="docs-heading-anchor-permalink" href="#OrientationConvention" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ImageEdgeDetection.OrientationConvention" href="#ImageEdgeDetection.OrientationConvention"><code>ImageEdgeDetection.OrientationConvention</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">    OrientationConvention(; compass_direction::AbstractChar = &#39;S&#39;, is_clockwise::Bool = false, in_radians = true, tol = sqrt(eps(Float64)))</code></pre><p>Specifies the coordinate system context for <code>detect_gradient_orientation</code> which determines the meaning of the angles (the gradient orientations).</p><p><strong>Details</strong></p><p>You can specify how you want the gradient orientation to be reported.  By default, the orientation is measured counter-clockwise from the south direction. This is because in a Raster coordinate system, the first spatial dimension increases as one goes down the image (i.e. it points south), and the second spatial dimension increases as one moves to the right of the image (i.e. it points east).</p><p>If you wish to interpret the orientation in a canonical Cartesian coordinate convention you would specify east as the reference compass direction (<code>compass_direction = &#39;E&#39;</code>) and a counter-clockwise direction (<code>clockwise = false</code>).</p><p>If <code>in_radians = true</code> the valid angles are reported in the range of <code>[0...2π)</code>, otherwise they are reported in the range <code>[0...360)</code>. The values <code>2π</code> and <code>360</code> are used as sentinels to designate undefined angles (because the gradient magnitude was too close to zero). By default, an angle is undefined if <code>(abs(g₁) &lt; tol &amp;&amp; abs(g₂) &lt; tol)</code> where <code>g₁</code> and <code>g₂</code> denote the gradient in the first and second spatial dimensions, and <code>tol = sqrt(eps(Float64))</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">
using TestImages, FileIO, ImageView, ImageEdgeDetection, ImageFiltering

img =  testimage(&quot;mandril_gray&quot;)

# Gradient in the first and second spatial dimension
g₁, g₂ = imgradients(img, KernelFactors.scharr)

# Interpret the angles with respect to a canonical Cartesian coordinate system
# where the angles are measured counter-clockwise from the positive x-axis.

orientation_convention = OrientationConvention(in_radians = true,
                                               is_clockwise = false,
                                               compass_direction = &#39;E&#39;)
angles = detect_gradient_orientation(g₁, g₂, orientation_convention)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/76b273c361f56896474157647ac6fe0aa3afff0d/src/algorithms/gradient_orientation.jl#L1-L49">source</a></section></article><h2 id="Supplementary-Types"><a class="docs-heading-anchor" href="#Supplementary-Types">Supplementary Types</a><a id="Supplementary-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Supplementary-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ImageEdgeDetection.Percentile" href="#ImageEdgeDetection.Percentile"><code>ImageEdgeDetection.Percentile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Percentile(x)</code></pre><p>Indicate that <code>x</code> should be interpreted as a <a href="https://en.wikipedia.org/wiki/Percentile">percentile</a> rather than an absolute value. For example,</p><ul><li><code>detect_edges(img, Canny(high = 80, low = 20))</code> uses absolute thresholds on the edge magnitudes</li><li><code>detect_edges(img, Canny(high = Percentile(80), low = Percentile(20)))</code> uses percentiles of the edge magnitude image as threshold</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageEdgeDetection.jl/blob/76b273c361f56896474157647ac6fe0aa3afff0d/src/ImageEdgeDetection.jl#L27-L32">source</a></section></article><ul><li><a href="#ImageEdgeDetection.Canny"><code>ImageEdgeDetection.Canny</code></a></li><li><a href="#ImageEdgeDetection.EdgeDetectionAPI.AbstractEdgeDetectionAlgorithm"><code>ImageEdgeDetection.EdgeDetectionAPI.AbstractEdgeDetectionAlgorithm</code></a></li><li><a href="#ImageEdgeDetection.EdgeDetectionAPI.AbstractEdgeThinningAlgorithm"><code>ImageEdgeDetection.EdgeDetectionAPI.AbstractEdgeThinningAlgorithm</code></a></li><li><a href="#ImageEdgeDetection.NonmaximaSuppression"><code>ImageEdgeDetection.NonmaximaSuppression</code></a></li><li><a href="#ImageEdgeDetection.OrientationConvention"><code>ImageEdgeDetection.OrientationConvention</code></a></li><li><a href="#ImageEdgeDetection.Percentile"><code>ImageEdgeDetection.Percentile</code></a></li><li><a href="#ImageEdgeDetection.SubpixelNonmaximaSuppression"><code>ImageEdgeDetection.SubpixelNonmaximaSuppression</code></a></li><li><a href="#ImageEdgeDetection.EdgeDetectionAPI.detect_edges"><code>ImageEdgeDetection.EdgeDetectionAPI.detect_edges</code></a></li><li><a href="#ImageEdgeDetection.EdgeDetectionAPI.detect_edges!"><code>ImageEdgeDetection.EdgeDetectionAPI.detect_edges!</code></a></li><li><a href="#ImageEdgeDetection.EdgeDetectionAPI.detect_subpixel_edges"><code>ImageEdgeDetection.EdgeDetectionAPI.detect_subpixel_edges</code></a></li><li><a href="#ImageEdgeDetection.EdgeDetectionAPI.detect_subpixel_edges!"><code>ImageEdgeDetection.EdgeDetectionAPI.detect_subpixel_edges!</code></a></li><li><a href="#ImageEdgeDetection.EdgeDetectionAPI.thin_edges"><code>ImageEdgeDetection.EdgeDetectionAPI.thin_edges</code></a></li><li><a href="#ImageEdgeDetection.EdgeDetectionAPI.thin_edges!"><code>ImageEdgeDetection.EdgeDetectionAPI.thin_edges!</code></a></li><li><a href="#ImageEdgeDetection.EdgeDetectionAPI.thin_subpixel_edges"><code>ImageEdgeDetection.EdgeDetectionAPI.thin_subpixel_edges</code></a></li><li><a href="#ImageEdgeDetection.EdgeDetectionAPI.thin_subpixel_edges!"><code>ImageEdgeDetection.EdgeDetectionAPI.thin_subpixel_edges!</code></a></li><li><a href="#ImageEdgeDetection.detect_gradient_orientation"><code>ImageEdgeDetection.detect_gradient_orientation</code></a></li><li><a href="#ImageEdgeDetection.detect_gradient_orientation!"><code>ImageEdgeDetection.detect_gradient_orientation!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 4 November 2021 01:21">Thursday 4 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
